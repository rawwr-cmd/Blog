# App Wrap Up in nutshell

We had imported Redux Thunk and then we imported or we wired it up to our reduc store through the use
of applied middleware in our root index.js We called Applied Middleware, which is a function from the redux library itself. And we passed the result of that into the second argument of the CREATE store called. When we apply that middleware of Redux thunk, any time that we dispatch an action, the action will be first sent to Redux Thunk as the middleware and then after Redux thunk, the action will be sent off to all of our different reducers. When we wired up Redux thunks it changed the rules of our action creators. So inside of our Action Creators file, we no longer had to create action. Creators that always returned in action object instead. With Redux thunk, we could also optionally return a function. If we return a function, it would be automatically called with the dispatch and get state arguments. And that essentially gave us total control over changing or getting information out of our reduc store. Any time that we expect to make an API request from an action creator, we are always going to make
use of something like Redux thunk. When we return, a function from our action creators. We use this really interesting syntax right here. All that's going on right there is we have a function that returns a function like so. So we had the outer function, outer function, and then whenever we called it, it automatically returned
this inner function, just as you see right there. we saw how we could create an action creator that somehow called other action creators and made sure that we still dispatch the result of calling those action creators. The last thing really quickly, our reducers, so we learned a ton about our reducers, we learned that the first argument is referred to as states and it is whatever was returned from this reducer the last time that it ran. So we run these reducers over and over again and whatever wherever we return shows up as that first argument, we learn that we usually make use of this switch statement syntax inside of reducers.
Again, this is a extremely common pattern. Inside of our users reducer, we saw some other really common syntax that
So remember, any time that we return some data from a reducer, we always have to return a new array or a new object or a different value string or a different value number. If we expect Redux to realize that we made a change to the data inside of our application, if we everjust return the exact same object or array redux has that very simple comparison where it just checks to see if that is the same object or array in memory.
And if it is, Redux says, oh, no data has changed and it does not update the rest of your application until the react side of your app to actually render itself and pull down new state and show some new content on the screen.
